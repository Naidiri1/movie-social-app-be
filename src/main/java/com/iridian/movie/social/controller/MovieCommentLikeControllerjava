// Add these imports to your FavoriteController
import com.iridian.movie.social.service.MovieCommentLikeService;
import com.iridian.movie.social.model.EntryType;
import org.springframework.beans.factory.annotation.Autowired;

// Add this field to your FavoriteController class
@Autowired(required = false)
private MovieCommentLikeService likeService;

// Replace the existing like/dislike methods with these:

    /**
     * Like a favorite entry
     * POST /api/favorites/{favoriteId}/like?userId=user123
     */
    @PostMapping("/{favoriteId}/like")
    public ResponseEntity<Map<String, Object>> likeFavorite(
            @PathVariable Long favoriteId,
            @RequestParam String userId) {
        
        // If service is not available, return mock data
        if (likeService == null) {
            Map<String, Object> mockResponse = new HashMap<>();
            
            // Still check if favorite exists and prevent self-liking
            Favorites favorite = favoriteRepository.findById(favoriteId)
                .orElseThrow(() -> new RuntimeException("Favorite not found"));
            
            if (favorite.getUser().getUserId().equals(userId)) {
                mockResponse.put("error", "You cannot like your own favorite");
                return ResponseEntity.badRequest().body(mockResponse);
            }
            
            mockResponse.put("action", "added");
            mockResponse.put("likes", 1L);
            mockResponse.put("dislikes", 0L);
            mockResponse.put("message", "Mock response - service not available");
            return ResponseEntity.ok(mockResponse);
        }
        
        try {
            // Use the actual service with FAVORITE entry type
            Map<String, Object> result = likeService.toggleLike(
                favoriteId,           // the favorite's ID
                "FAVORITE",          // entry type is FAVORITE
                userId,              // user doing the liking
                true                 // true for like
            );
            
            // Add additional info
            result.put("entryId", favoriteId);
            result.put("entryType", "FAVORITE");
            
            return ResponseEntity.ok(result);
        } catch (RuntimeException e) {
            return ResponseEntity.badRequest()
                .body(Map.of("error", e.getMessage()));
        }
    }
    
    /**
     * Dislike a favorite entry
     * POST /api/favorites/{favoriteId}/dislike?userId=user123
     */
    @PostMapping("/{favoriteId}/dislike")
    public ResponseEntity<Map<String, Object>> dislikeFavorite(
            @PathVariable Long favoriteId,
            @RequestParam String userId) {
        
        // If service is not available, return mock data
        if (likeService == null) {
            Map<String, Object> mockResponse = new HashMap<>();
            
            // Still check if favorite exists and prevent self-disliking
            Favorites favorite = favoriteRepository.findById(favoriteId)
                .orElseThrow(() -> new RuntimeException("Favorite not found"));
            
            if (favorite.getUser().getUserId().equals(userId)) {
                mockResponse.put("error", "You cannot dislike your own favorite");
                return ResponseEntity.badRequest().body(mockResponse);
            }
            
            mockResponse.put("action", "added");
            mockResponse.put("likes", 0L);
            mockResponse.put("dislikes", 1L);
            mockResponse.put("message", "Mock response - service not available");
            return ResponseEntity.ok(mockResponse);
        }
        
        try {
            // Use the actual service with FAVORITE entry type
            Map<String, Object> result = likeService.toggleLike(
                favoriteId,           // the favorite's ID
                "FAVORITE",          // entry type is FAVORITE
                userId,              // user doing the disliking
                false                // false for dislike
            );
            
            // Add additional info
            result.put("entryId", favoriteId);
            result.put("entryType", "FAVORITE");
            
            return ResponseEntity.ok(result);
        } catch (RuntimeException e) {
            return ResponseEntity.badRequest()
                .body(Map.of("error", e.getMessage()));
        }
    }
    
    /**
     * Get like/dislike counts for a favorite
     * GET /api/favorites/{favoriteId}/likes?userId=user123
     */
    @GetMapping("/{favoriteId}/likes")
    public ResponseEntity<Map<String, Object>> getFavoriteLikes(
            @PathVariable Long favoriteId,
            @RequestParam(required = false) String userId) {
        
        // Verify favorite exists
        if (!favoriteRepository.existsById(favoriteId)) {
            return ResponseEntity.notFound().build();
        }
        
        // If service is not available, return mock data
        if (likeService == null) {
            Map<String, Object> mockData = new HashMap<>();
            mockData.put("likes", 5L);
            mockData.put("dislikes", 2L);
            mockData.put("userStatus", userId != null ? "liked" : null);
            mockData.put("message", "Mock response - service not available");
            mockData.put("entryId", favoriteId);
            mockData.put("entryType", "FAVORITE");
            return ResponseEntity.ok(mockData);
        }
        
        try {
            // Use the actual service to get like data
            Map<String, Object> data = likeService.getLikeData(
                favoriteId,              // the favorite's ID
                EntryType.FAVORITE,      // entry type
                userId                   // current user (optional)
            );
            
            return ResponseEntity.ok(data);
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(Map.of("error", e.getMessage()));
        }
    }
    
    /**
     * Alternative: React endpoint with action parameter
     * POST /api/favorites/{favoriteId}/react?action=like&userId=user123
     */
    @PostMapping("/{favoriteId}/react")
    public ResponseEntity<Map<String, Object>> reactToFavorite(
            @PathVariable Long favoriteId,
            @RequestParam String action,  // "like", "dislike", or "remove"
            @RequestParam String userId) {
        
        if (likeService == null) {
            return ResponseEntity.status(503)
                .body(Map.of("error", "Like service not available"));
        }
        
        try {
            boolean isLike = "like".equals(action);
            
            Map<String, Object> result = likeService.toggleLike(
                favoriteId,
                "FAVORITE",
                userId,
                isLike
            );
            
            result.put("requestedAction", action);
            return ResponseEntity.ok(result);
        } catch (RuntimeException e) {
            return ResponseEntity.badRequest()
                .body(Map.of("error", e.getMessage()));
        }
    }
    
    /**
     * Get favorites with like counts included
     * This enriches the favorite DTOs with like/dislike information
     */
    @GetMapping("/with-likes")
    public ResponseEntity<List<FavoriteFlat>> getFavoritesWithLikes(
            @RequestParam String userId,
            @RequestParam(required = false) String viewerId) {
        
        List<Favorites> favorites = favoriteRepository.findByUserUserId(userId);
        List<FavoriteFlat> dtos = favorites.stream()
                .map(this::convertToFlatDTO)
                .collect(Collectors.toList());
        
        // If like service is available, enrich with like data
        if (likeService != null && !dtos.isEmpty()) {
            try {
                // You'll need to make FavoriteFlat extend MovieEntryDTO
                // Or create a method specifically for FavoriteFlat
                for (FavoriteFlat dto : dtos) {
                    Map<String, Object> likeData = likeService.getLikeData(
                        dto.getId(),
                        EntryType.FAVORITE,
                        viewerId  // who is viewing (for userStatus)
                    );
                    
                    dto.setCommentLikes((Long) likeData.get("likes"));
                    dto.setCommentDislikes((Long) likeData.get("dislikes"));
                    dto.setUserLikeStatus((String) likeData.get("userStatus"));
                }
            } catch (Exception e) {
                // Log error but still return the data without likes
                System.err.println("Error enriching with like data: " + e.getMessage());
            }
        }
        
        return ResponseEntity.ok(dtos);
    }